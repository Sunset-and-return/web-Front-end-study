# HTML + CSS

# JavaScript

### 问：js 数据类型

-   基本数据类型
    -   number
        -   NaN：number 中的特殊值，NaN != NaN
    -   string
    -   undefined
        -   声明了但是未定义
    -   null
        -   空对象指针，在 typeof 检测时候结果为 object
    -   boolean
    -   symbol
        -   永不相等
    -   bigint
-   引用数据类型
    -   object
        -   object
        -   array
        -   function
    -   声明的对象会保存在堆中，但是它的地址会保存在栈内存中

### 问：堆和栈的区别

（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由 C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者 BSS 段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

### 问：栈和队列的区别

**栈与队列的相同点：**

1. 都是线性结构。

2. 插入操作都是限定在表尾进行。

3. 都可以通过顺序结构和链式结构实现。、

4. 插入与删除的时间复杂度都是 O（1），在空间复杂度上两者也一样。

5. 多链栈和多链队列的管理模式可以相同。

**栈与队列的不同点：**

1. 删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。

2. 应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。

3. 顺序栈能够实现多栈空间共享，而顺序队列不能。

### 问：undefined 和 null 的区别

-   `undefined` 转换为数字为 `NaN`，`null` 转换为数字为 `0`；
-   `typeof undefined === 'undefined'`，`typeof null === 'object'`
-   `undefined` 表示一个变量自然的、最原始的状态值，也就是未定义，而 `null` 则表示一个变量被人为的设置为空对象

### 问：`==`和`===`的区别

1. `==`比较的是两边的值是否相等，与类型无关，如果两边值类型不同的时候，先进行类型转换，再比较；比如说`“1”=true`

2. `===`：比较的是值和类型都有相等，类型不同就是不等
3. `Object.is()`是 ES6 新增的用来比较两个值是否相等的方法，与`===`的行为基本一致，区别在于：一是+0 不等于-0，二是 NaN 等于自身。

### 问：`==` 的比较规则

-   原始类型的值
    原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值。
-   对象与原始类型值比较
    对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。
-   undefined 和 null
    undefined 和 null 与其他类型的值比较时，结果都为 false，它们互相比较时结果为 true。
-   相等运算符"`==`"的缺点
    相等运算符"`==`"隐藏的类型转换，会带来一些违反直觉的结果。

### 问：js 为什么是单线程

-   单线程 - 只有一个线程，只能做一件事
-   原因
    -   避免 `DOM` 渲染的冲突
    -   浏览器需要渲染 `DOM`
    -   `JS` 可以修改 `DOM` 结构
    -   `JS` 执行的时候，浏览器 `DOM` 渲染会暂停
    -   两段 `JS` 也不能同时执行（都修改 `DOM` 就冲突了）
    -   `webworker` 支持多线程，但是不能访问 `DOM`
-   解决方案 - 异步

### 问：面向对象的了解

-   封装
    -   封装就是将一类事物的属性和行为抽象为一个类，使其属性私有化，行为公开化，提高数据的隐秘性的同时，使得代码模块化。这样使得代码的复用性更高。
-   继承
    -   继承则是进一步将一类事物共有的属性和行为抽象为一个类，而每一个子类是一个特殊的父类-有父类的行为和属性，也有自己的特有的行为和属性。这样做扩展了已存在的代码块，进一步提高了代码的复用性。
-   多态
    -   如果说封装和继承是为了代码的复用，那么多态则是为了实现接口的复用。多态的一大作用就是为了解耦--为了解除父子类继承的耦合度。如果说继承中父子类关系是继承的关系，那么接口和实现类之间的关系是组合关系。简单的来说，多态就是允许父类的引用（或接口）指向子类（或实现类）对象。很多设计模式都是基于面向对象的多态性设计的。

### 问：new操作符

1. 创建一个空对象，构造函数中的this指向这个空对象
2. 这个新对象被执行 [[prototype]] 连接
3. 执行构造函数方法，属性和方法被添加到this引用的对象中
4. 如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。



### 问：ES6

1. var、let 和 const

2. 解构赋值

    1. 解构赋值主要是针对于对象和数组的：真实项目中，一般常用于把从服务器获取的 json 数据进行快速的解构,赋值给对应的变量，帮组我们快速的拿到对应的结果

    2. 当明确要获取哪些属性时：

    3.  - 数组：es6 数组解构比 es5 效率更低，通过数组解构或对象解构对数组属性值进行获取，对象解构效率更高；
        - 对象：es6 对象解构跟 es5 效率基本一致；
        - 数组-对象：es5 下效率基本一致，es6 下对象解构会更快一些；

    4. 当明确要获取哪些属性：

    5.  - 解构数组时：我们可以选择对象解构来解构数组，首先是因为这种情况下它的效率会更高一些，同时对象解构的代码可读性、可维护性更高（比如：let [a, , b] = [1, 2, 3] 和 let { 0: a, 2: b } = [1, 2, 3]）;
        - 函数参数解构时，我们也可以使用对象解构，原因同上；

    6. 实际上，数组解构和对象解构性能上并没有相差太大，不用刻意去比较，场景适合哪种解构就用哪种解构；

    7. 相比于数组解构，对象解构的可读性和代码可维护性会好些，因为不需要像数组解构那样去跳过某个值而去获取下一个值；

3. 箭头函数

4. 扩展运算符

5. Symbol

6. Set 和 Map

7. Proxy

8. Promise

### 问：var、let、const 的区别

-   作用域：`let` 和 `const` 是块级作用域，`var` 是函数作用域
-   变量提升：`let` 和 `const` 不存在变量提升，`var` 存在变量提升
-   暂时性死区
    -   只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量
    -   为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。
-   声明覆盖：`let` 和 `const` 不能重复声明覆盖，`var` 可以重复声明覆盖
-   `let`、`const` 声明的全局变量不会挂在顶层对象（`window`）下面
-   `const` 声明之后必须马上赋值，否则会报错；`const` 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。

### 问：promise

### 问：Set 和 Map

-   Set
    -   Set 是一种叫做集合的数据结构
    -   Set 中成员的值是唯一的，没有重复。
    -   属性和方法
        -   属性
            -   `Set.prototype.conctructor`
            -   `Set.prototype.size`
        -   方法
            -   操作方法
                `add(value)：增`
                `delete(value)：删`
                `has(value)：查`
                `claer()：清空`
            -   遍历方法
                `keys()：遍历器对象，输出键名`
                `values()：遍历器对象，输出键值`
                `entries()：遍历器对象，输出键名和键值`
                `forEach()：使用回调函数遍历每个成员`

### 问：Set 和 Map 的区别

1. Set 集合就是，一种有序列表，含有相对独立的非重复值

    - 初始化：`new Set(["name","yun"])`转化为数组就是，`arr = [... new Set(arr1)]`

2. Map 类型就是一种许多键值对的有序列表，其中的键名和对应的值支持所有的数据类型
    - 初始化就是：`new Map([["name","yun"],["age"],"25"])`

### 问：Map 和 Object 的区别

##### 1.同名碰撞

Map 的键存的就是内存的地址。只要地址不一样，就是两个不同的键，这就解决了同名属性的碰撞问题，而传统的 Object 显然做不到这一点。

##### 2.可迭代

Map 实现了迭代器，可用 for...of 遍历，而 Object 不行

##### 3.长度

Map 可以直接拿到长度，而 Object 不行。

##### 4.有序性

填入 Map 的元素，会保持原有的顺序，而 Object 无法做到。

##### 5.可展开

Map 可以使用省略号语法展开，而 Object 不行。

### 问：箭头函数

1、语法更加简洁、清晰
2、箭头函数没有 prototype (原型)，所以箭头函数本身没有 this
3、箭头函数不会创建自己的 this
4、call | apply | bind 无法改变箭头函数中 this 的指向
5、箭头函数不能作为构造函数使用
6、箭头函数不绑定 arguments，取而代之用 rest 参数...代替 arguments 对象，来访问箭头函数的参数列表
7、箭头函数不能用作 Generator 函数，不能使用 yield 关键字

### 问：浏览器存储 cookie、localStorage、sessionStorage

1. **从浏览器和服务器间的传递看：**cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存
2. **从大小看：**存储大小限制不同，cookie 数据不能超过 4K，只适合保存很小的数据；而 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大
3. **从数据有效期看：**sessionStorage 在会话关闭会立刻关闭，因此持续性不久；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。而 localStorage 始终有效
4. **从作用域看：**sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；而 localStroage 和 cookie 都是可以所有的同源窗口中共享的

# 设计模式

### 问：发布订阅模式和观察者模式的区别

首先，我觉得发布订阅模式属于观察者模式的变种，因为他们在概念上是相似的，我在《Head First 设计模式》里看过这么一句话，发布者 + 订阅者 = 观察者模式，但是他们也有挺多的不同之处

-   在**观察者**模式中，观察者是知道 `Subject` 的，`Subject` 一直保持对观察者进行记录。然而，在**发布订阅**模式中，发布者和订阅者**不知道对方的存在**。它们只有通过消息代理进行通信。
-   在**发布订阅**模式中，组件是松散耦合的，正好和观察者模式相反。
-   **观察者模式**大多数时候是**同步**的，比如当事件触发，`Subject` 就会去调用观察者的方法。而**发布-订阅**模式大多数时候是**异步的**（使用消息队列）。
-   **观察者** 模式需要在单个应用程序地址空间中实现，而**发布-订阅**更像交叉应用模式。

### 问：发布/订阅模式的优缺点

优点：解耦

缺点：

- 中间人也许不会通知系统消息传送的状态。所以我们无法知道消息传送是成功的还是失败的。紧耦合是需要保证这一点的。
- 发布者不知道订阅者的状态，反之亦然，这样的话，你根本不知道在另一端是否会没有问题？
- 随着订阅者和发布者数量的增加，不断增加的消息传送回导致架构的不稳定，容易在负载大的时候出问题
- 攻击者（恶意的发布者）能够入侵系统并且撕开它。这会导致恶意的消息被发布，订阅者能够获得他们以前并不能获得的消息。
- 更新发布者和订阅者的关系会是一个很难的问题，因为毕竟他们根本不认识对方。
- 需要中间人/代理商，消息规范和相关的规则会给系统增加一些复杂度

### 问：23 种设计模式

#### 1. 根据目的来分

根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。

1. **创建型模式：**用于描述**“怎样创建对象”**，它的主要特点是**“将对象的创建与使用分离”**。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
2. **结构型模式：**用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
3. **行为型模式：**用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

#### 2. 根据作用范围来分

根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。

1. **类模式：**用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF 中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. **对象模式：**用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。

#### 3. GoF 的 23 种设计模式的功能

前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。

1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

# 算法

### 问：数组去重

1. 使用 Set 数据结构

    1. `[...new Set(oldArr)]`
    2. `Array.from(new Set(oldArr))`

2. 拿出前面的项和后面的内容做对比

    ```js
    for (let i = 0; i < arr.length - 1; i++) {
    	let item = arr[i]
    	// newArr.indexOf(item) === -1 ? newArr.push(item) : '';
    	// newArr.lastIndexOf(item) === -1 ? newArr.push(item) : '';
    	newArr.includes(item) === false ? newArr.push(item) : ""
    }
    ```

3. 拿数组中的每一项向新容器中存储，如果已经存储过了，把当前项去掉

    ```js
    for (let i = 0; i < arr.length; i++) {
    	if (typeof obj[arr[i]] !== "undefined") {
    		continue
    	}
    	obj[arr[i]] = arr[i]
    	newArr.push(arr[i])
    }
    ```

4. 先排序，再相邻比较

### 问：数组扁平化

1. ES6 新增方法 `Array.prototype.flat(Infinity)`
2. 递归
3. `reduce()`
4. `toString() + split()`
5. 数组的扩展运算符

### 问：排序算法

![排序算法](./笔记图片/排序算法.png)

[十大排序算法](https://www.cnblogs.com/onepixel/articles/7674659.html)

### 问：链表删除节点

```C
p=GetElem(L,i-1);  //查找删除位置的前驱结点
q=p->next;  //令q指向被删除结点
p->next=q->next  //将*q结点从链中“断开”
free (q) ;  //释放结点的存储空间
```

-   找到被删除节点的前一个节点 `p`
-   定义一个变量 `q` ，`q` 指向 `p->next` 也就是被删除的节点
-   令 `p->next = q->next`

# 网络

### 问：HTTP 0.9/1.0/1.x/2.0 的区别

##### 1.0 新增

-   增加了 MEAD、POST 方法
-   增加了 HTTP headers 和响应状态码

##### 1.x 新增

-   持久连接（Keep-Alive）
-   增加了 PUT、DELETE、OPTIONS 等方法
-   新增了断点续传，身份认证，状态管理，缓存等待性

##### 2.0 新增

-   二进制分帧
    -   HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。
-   头部压缩
    -   header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。
-   多路复用
    -   即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。
-   服务器推送
    -   服务端推送能把客户端所需要的资源伴随着 `index.html` 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。

### 问：为什么 HTTP2.0 能够做到多路复用

多路复用代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP 连接并发完成。因为在多路复用之前所有的传输是基于基础文本的，在多路复用中是基于二进制数据帧的传输、消息、流，所以可以做到乱序的传输。多路复用对同一域名下所有请求都是基于流，所以不存在同域并行的阻塞。

### 问：对 HTTP 3.0 的了解

1. HTTP 3.0 是基于 UDP 实现的
2. 谷歌在 UDP 基础上改造一个具备 TCP 协议优点的新协议 QUIC 协议。
3. HTTP2.0 协议的多路复用机制解决了 HTTP 层的队头阻塞问题，但是在 TCP 层仍然存在队头阻塞问题。
4. QUIC 协议是基于 UDP 协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。

### 问：get 和 post 的区别

-   GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
-   GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
-   GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
-   GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
-   GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
-   GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。
-   对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
-   GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
-   GET 参数通过 URL 传递，POST 放在 Request body 中。
-   GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。
    -   对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
    -   而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。
    -   也就是说，GET 只需要汽车跑一趟就把货送到了，而 POST 得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
    -   因为 POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。因此 Yahoo 团队有推荐用 GET 替换 POST 来优化网站性能。但这是一个坑！跳入需谨慎。为什么？
        1. GET 与 POST 都有自己的语义，不能随便混用。
        2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。
        3. 并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。

### 问：多路复用和长连接的区别

简单来说就是：在长连接出现之前，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间；而长连接是一直保持着 TCP 连接，在同一个 TCP 连接，同一时刻长连接只能传输一个 HTTP 请求，只有当这个 HTTP 请求完成之后才能继续传输下一个；而多路复用是在同一个 TCP 连接，同一时刻可以传输多个 HTTP 请求，单个连接上可以并行交错的请求和响应，之间互不干扰，对端可以通过帧中的标识知道属于哪个请求。通过多路复用可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

**http/1.0：**如需要发送多个请求必须创建多个 TCP 连接，并且浏览器对于单域名请求有数量限制（一般 6 个），其连接无法被复用

**http/1.1：**引入流水线（Pipelining）技术，但先天 FIFO（先进先出）机制导致当前请求的执行依赖于上一个请求执行的完成，容易引起报头阻塞，并没有从根本上解决问题

**http/2：**重新定义底层 http 语义映射，允许同一个连接上使用请求和响应双向数据流。同一域名只需占用一个 TCP 连接，通过数据流（Stream）以帧为基本协议单位，从根本上解决了问题，避免了因频繁创建连接产生的延迟，减少了内存消耗，提升了使用性能

### 问：HTTP 和 HTTPS 的区别

简单来说，HTTPS 就是 HTTP 加上了 SSL 通道

-   https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。

-   http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。

-   http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

-   http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

### 问：HTTPS 的连接过程

1. 客户端向服务端发送一个招呼报文（hello），包含自己支持的 SSL 版本，加密算法等信息。

2. 服务端回复一个招呼报文（hi）包含自己支持的 SSL 版本，加密算法等信息。

3. 服务端发送自己经过 CA 认证的公开密钥

4.  1. 服务端向 CA 认证机构发送自己的公开密钥（FPkey）
    2. CA 认证机构使用自己的私有密钥给 FPkey 加上签名返回给服务端

5. 客户端在接受到服务端发来的 SSL 证书时，会对证书的真伪进行校验

    1. 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
    2. 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发
    3. 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
    4. 如果找到，那么浏览器就会从操作系统中取出 颁发者 CA 的公钥，然后对服务器发来的证书里面的签名密文进行解密，得到摘要。
    5. 浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值（摘要），将这个计算的 hash 值（摘要）与证书中签名做对比
    6. 对比结果一致，则证明服务器发来的证书合法，没有被冒充
    7. 此时浏览器就可以读取证书中的公钥，用于后续加密了

6. 服务端发送结束招呼的报文，SSL 第一次握手结束。

7. 客户端使用 FPkey 对自己的随机密码串（Ckey）进行加密并发送给服务端

8.  1. 客户端首先使用 CA 的公开密钥对 FPkey 的签名进行认证，确认密钥未被替换

9. 客户端发送提示报文，后续报文将用 Ckey 进行加密。

10. 客户端发送 finished 报文，表示该次发送结束

11. 1. 后续是否通信取决于客户端的 finished 报文能否被服务端成功解密

12. 服务端发送提示报文，表示他之后的报文也会用 Ckey 进行加密

13. 服务端发送 finished 报文。至此 SSL 握手结束，成功建立 SSL 连接。

14. 客户端开始发送 http 请求报文

15. 1. 建立 Tcp 连接，开始传输数据

16. 服务端发送 http 回复报文

17. 客户端发送断开连接报文，并断开 Tcp 连接

### 问：讲一下 DNS 查询

-   当客户端程序要通过一个主机名称来访问网络中的一台主机时，它首先要得到这个主机名称所对应的 IP 地址，因为 IP 数据报中允许放置的是目的主机的 IP 地址，而不是主机名称。可以从本机的 hosts 文件中得到主机名称所对应的 IP 地址，但如果 hosts 文件不能解析该主机名称时，只能通过向客户机所设定 DNS 服务器进行查询了。
-   **本地解析：** 客户端平时得到的 DNS 查询记录都保存在 DNS 缓存中，客户端的操作系统中都会运行着一个 DNS 客户端程序。当其他程序提出 DNS 查询请求的时候，这个查询请求会经过 DNS 客户端程序，DNS 客户端会使用本地的缓存信息进行解析，如果可以查询到，那么 DNS 客户端程序就会直接应答这个查询，而不需要向 DNS 服务器查询。
-   **直接解析：** 如果 DNS 客户端程序进行本地解析失败，也就是说本地缓存中无法查询到，那么他就会向客户端所设定的局部 DNS 服务器发送一个查询请求，要求局部 DNS 服务器进行解析，局部 DNS 服务器在得到这个请求之后会查看一个所需要查询的域名是不是自己能够应答的，如果是能够应答的，那么就会给予回答，如果不能就会查看自己的 DNS 缓存，如果能从缓存中解析，也会直接给予回应。
-   **递归解析：** 当局部 DNS 服务器自己不能回答客户机的 DNS 查询时，它就需要向其他 DNS 服务器进行查询。局部 DNS 服务器自己负责向其他 DNS 服务器进行查询，一般是先向该域名的**根域服务器**查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部 DNS 服务器，再由局部 DNS 服务器返回给客户端。
-   **迭代解析：** 当局部 DNS 服务器自己不能回答客户机的 DNS 查询时，也可以通过迭代查询的方式进行解析，如图所示。局部 DNS 服务器不是自己向其他 DNS 服务器进行查询，而是把能解析该域名的其他 DNS 服务器的 IP 地址返回给客户端 DNS 程序，客户端 DNS 程序再继续向这些 DNS 服务器进行查询，直到得到查询结果为止。

### 问：TCP 三次握手和四次挥手

#### 三次握手

-   **第一次握手：**客户端向服务器端发送请求连接报文，其中包括自身的数据通信初始码（seq）。发送请求之后，客户端进入了人 SYN-SENT 状态。
-   **第二次握手：**服务器端接收到请求连接报文，如果同意连接，这时候服务端就会回复一个报文段，其中也会包含自身的数据通信数据码（seq），在发送之后，便进入 SYN-RECEIVED 状态。
-   **第三次握手：**客户端接收到服务端的报文段。还要向服务端发送一个确认报文。客户端在发送完成之后就进行了 ESTABLISHED 状态，服务端在接收到这个请求之后也进入 ESTABLISHED 状态。此时客户端建立连接完成。

#### 四次挥手

-   **第一次挥手：**如客户端认为数据完成发送，需要向服务器端发送释放连接的请求。客户端进入 FIN_WAIT_1 状态。
-   **第二次挥手：**服务器端接收到客户端的连接释放请求，会告诉应用层要释放 TCP 连接，然后发送 ACK 到客户端，然后进入 CLOSE_WAIT 状态。此时表明客户端到服务器端的连接已经释放，不会接受来自客户端的数据了，但由于 TCP 是全双工的。所以此时服务端还可以向客户端发送数据。
-   **第三次挥手：**服务器端如果在此时数据还没有发送完成，会继续发送，在数据发送完毕之后。服务器端会向客户端发送连接释放请求。然后服务器端进入 LAST_ACK 状态。
-   **第四次挥手：**客户端在接受到服务器端的释放请求，会向服务器端再发送一个确认请求。此时客户端进入 TIME_WAIT 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间内没有服务器端的重发请求的话，就进入 CLOSED 状态。当客户端收到确认应答后，也便进入 CLOSED 状态

### 问：为什么要三次握手而不是两次

借用《计算机网络》这本书的一句话来说就是：防止已失效的连接请求又传送到服务器端，因而产生错误。

-   为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
-   如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

### 问：TCP 拥塞控制是如何实现的？

### 问：TCP 和 UDP 的区别？

1、TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需要建立连接
2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保 证可靠交付
3、TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的
UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）
4、每一条 TCP 连接只能是点到点的;UDP 支持一对一，一对多，多对一和多对多的交互通信
5、TCP 首部开销 20 字节;UDP 的首部开销小，只有 8 个字节
6、TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道

### 问：OSI 七层模型、五层模型、TCP/IP 四层模型

| OSI 七层模型 | 五层模型   | TCP/IP 模型 |
| ------------ | ---------- | ----------- |
| 应用层       |            |             |
| 表示层       |            |             |
| 会话层       | 应用层     | 应用层      |
| 传输层       | 传输层     | 传输层      |
| 网络层       | 网络层     | 网络层      |
| 数据链路层   | 数据链路层 | 网络接口层  |
| 物理层       | 网络层     |             |

### 问：cookie 和 session 的区别

1. cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个 WEB 站点会话间持久的保持数据。

2. session 其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session 其实是利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个 Cookie，当这个 Session 结束时，其实就是意味着这个 Cookie 就过期了。
   注：为这个用户创建的 Cookie 的名称是 aspsessionid。这个 Cookie 的唯一目的就是为每一个用户提供不同的身份认证。

3. cookie 和 session 的共同之处在于：cookie 和 session 都是用来跟踪浏览器用户身份的会话方式。

4. cookie 和 session 的区别是：cookie 数据保存在客户端，session 数据保存在服务器端。
5. 两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于 session 是放在服务器上的，过期与否取决于服务期的设定，cookie 是存在客户端的，过去与否可以在 cookie 生成的时候设置进去。
    - cookie 数据存放在客户的浏览器上，session 数据放在服务器上
    - cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗,如果主要考虑到安全应当使用 session
    - session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用 COOKIE
    - 单个 cookie 在客户端的限制是 3K，就是说一个站点在客户端存放的 COOKIE 不能 3K。
    - 所以：将登陆信息等重要信息存放为 SESSION;其他信息如果需要保留，可以放在 COOKIE 中

### 问：cookie、sessionStorage 和 localStorage 的区别

1. **从浏览器和服务器间的传递看：**cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存
2. **从大小看：**存储大小限制不同，cookie 数据不能超过 4K，只适合保存很小的数据；而 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大
3. **从数据有效期看：**sessionStorage 在会话关闭会立刻关闭，因此持续性不久；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。而 localStorage 始终有效
4. **从作用域看：**sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；而 localStroage 和 cookie 都是可以所有的同源窗口中共享的

# webpack

### 问：loader 和 plugin 的区别

loader：简单来说就是一个转换器，将 A 文件进行编译成 B 文件，让 webpack 能够处理非 js 文件(自身职能理解 js)，然后你就可以利用 webpack 的打包能力，对它们进行处理。
例如：css-loader、style-loader、postcss-loader、sass-loader、file-loader、url-loader、babel-loader

plugins：是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。从打包优化和压缩，一直到重新定义环境中的变量.
例如：uglify-webpack-plugin、clean-webpack-plugin、babel-polyfill

### 问：webpack 热更新原理

1. 当修改了一个或多个文件；

2. 文件系统接收更改并通知 webpack；

3. webpack 重新编译构建一个或多个模块，并通知模块热替换（HMR）服务器进行更新；

4. 模块热替换（HMR） Server 使用 webSocket 通知模块热替换（HMR） runtime 需要更新，HMR 运行时通过 HTTP 请求更新 jsonp；

5. HMR 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。

# Vue

### 问：Vue 2.0 / 3.0 双向数据绑定的实现原理

##### Vue 2.0 （ES5：`Object.defineProperty`）

```html
<body>
	姓名：<span id="spanName"></span>
	<br />
	<input type="text" name="" id="inpName" />
	<script>
		let obj = {
			name: "",
		}
		let newObj = JSON.parse(JSON.stringify(obj))

		Object.defineProperty(obj, "name", {
			get() {
				return newObj.name
			},
			set(value) {
				if (value === newObj.name) return
				newObj.name = value
				observe()
			},
		})

		// let spanName = document.querySelector('#spanName');
		// let inpName = document.querySelector('#inpName');

		function observe() {
			spanName.innerHTML = obj.name
			inpName.value = obj.name
		}

		inpName.oninput = function () {
			obj.name = this.value
		}
	</script>
</body>
```

##### Vue 3.0 （ES6：`Proxy`）

```html
<body>
	姓名：<span id="spanName"></span>
	<br />
	<input type="text" name="" id="inpName" />
	<script>
		let obj = {}
		obj = new Proxy(obj, {
			get(target, prop) {
				// console.log(target, target[prop]);
				return target[prop]
			},
			set(target, prop, value) {
				target[prop] = value
				observe()
				console.log(target, target[prop])
			},
		})

		function observe() {
			spanName.innerHTML = obj.name
			inpName.value = obj.name
		}

		inpName.oninput = function () {
			obj.name = this.value
		}
	</script>
</body>
```

### 问：vue 的响应式原理

简单说：主要是采用数据劫持结合发布者-订阅者模式，在数据初始化的时候，使用`Observer` 方法去观察对象数据，在这个方法中最主要使用 `Object.defineProperty()` 方法去监听劫持所有 `data` 属性，(如果属性值仍然是对象，就会递归这个对象)

然后每个属性创建一个 `Dep` 对象，在 `object.defindproperty()` 中有 `set()` 和 `get()` 函数，在页面模板解析时候，会创建 `watcher` 实例，页面取对应的值时会调用 `get()` 函数，

在调用 `get` 函数的时候就会用 `Dep` 对象中的 `subs` 数组进行依赖收集（收集当前的`watcher`），如果属性发生变化会调用 `set()` 函数，接着会调用 `dep` 对象中的 `notify()` 函数，通知相关的 `watcher` 进行 `updata()` 操作。

### 问：Vue 2.0 / 3.0 双向数据绑定的实现过程

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>vue</title>
	</head>
	<body>
		姓名：<span id="spanName"></span>
		<br />
		<input type="text" name="" id="inpName" />
		<script>
			let obj = {
				name: "",
			}
			let newObj = JSON.parse(JSON.stringify(obj))

			Object.defineProperty(obj, "name", {
				get() {
					return newObj.name
				},
				set(value) {
					if (value === newObj.name) return
					newObj.name = value
					observe()
				},
			})

			// let spanName = document.querySelector('#spanName');
			// let inpName = document.querySelector('#inpName');

			function observe() {
				spanName.innerHTML = obj.name
				inpName.value = obj.name
			}

			inpName.oninput = function () {
				obj.name = this.value
			}

			/*
			 * 1. 对原始数据进行克隆
			 * 2. 需要分别给对象中的每一个属性设置监听
			 */
		</script>
		<script>
			let obj = {}
			obj = new Proxy(obj, {
				get(target, prop) {
					// console.log(target, target[prop]);
					return target[prop]
				},
				set(target, prop, value) {
					target[prop] = value
					observe()
					console.log(target, target[prop])
				},
			})

			function observe() {
				spanName.innerHTML = obj.name
				inpName.value = obj.name
			}

			inpName.oninput = function () {
				obj.name = this.value
			}
		</script>
	</body>
</html>
```

### 问：proxy 和 defineProperty 的优缺点

`Object.defineProperty()` 的缺点：

-   `Object.defineProperty` 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。
-   `Object.defineProperty` 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。如 Vue 2.x 里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历

`proxy` 的优点：

-   可以劫持整个对象，并返回一个新对象，并且也可以直接监听数组的变化
-   有 13 种劫持操作，比如 apply、ownKeys、deleteProperty、has 等等

`Object.defineProperty` 的优点：

-   兼容性好，兼容 IE9

### 问：MVC 和 MVVM 的区别

##### MVC

典型思路是 `View` 层通过事件通知到 `Controller` 层，`Controller` 层经过对事件的处理完成相关业务逻辑，要求 `Model` 层改变数据状态，`Model` 层再将新数据更新到 `View`层。

##### MVVM

引入双向绑定机制，帮助实现一些更新视图层和模型层的工作，让开发者可以更专注于业务逻辑，相比于之前的模式，可以使用更少的代码量完成更复杂的交互

### 问：什么是生命周期，有什么作用

- Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

- 它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

### 问：生命周期的阶段

1. **beforecreate（创建之前）**
   完成实例初始化，初始化非响应式变量
   this指向创建的实例；
   可以在这加个loading事件；
   data computed watch methods上的方法和数据均不能访问

2. **created（创建之后）**
   实例创建完成
   完成数据(data props computed)的初始化 导入依赖项。
   可访问data computed watch methods上的方法和数据
   未挂载DOM,不能访问el,*e**l*,ref为空数组
   可在这结束loading，还做一些初始化，实现函数自执行,
   可以对data数据进行操作，可进行一些请求，请求不易过多，避免白屏时间太长。
   若在此阶段进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中

3. **berofeMount（挂载之前）**
   有了el,编译了template|/outerHTML
   能找到对应的template,并编译成render函数

4. **mounted（挂载之后）**
   完成创建 `vm.$el`，和双向绑定，
   完成挂载DOM 和渲染;可在mounted钩子对挂载的dom进行操作
   即有了DOM 且完成了双向绑定 可访问DOM节点,​`$ref`
   可在这发起后端请求，拿回数据，配合路由钩子做一些事情；
   可对DOM 进行操作

5. **beforeUpdate（虚拟DOM更新之前）**
   数据更新之前
   可在更新前访问现有的DOM,如手动移除添加的事件监听器；

6. **updated（虚拟DOM更新之后）**
   完成虚拟DOM的重新渲染和打补丁；
   组件DOM 已完成更新；
   可执行依赖的dom 操作
   **注意：**不要在此函数中操作数据，会陷入死循环的。

7. **activated**
   在使用vue-router时有时需要使用`<keep-alive></keep-alive>`来缓存组件状态，这个时候created钩子就不会被重复调用了，
   如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发

8. **deactivated**
   for keep-alive 组件被移除时使用

9. **beforeDestroy（实例被销毁前调用）**
   在执行 `app.$destroy()` 之前
   可做一些删除提示，如：你确认删除XX吗？
   可用于销毁定时器，解绑全局时间 销毁插件对象

10. **destroyed（实例被销毁之后调用）**

    当前组件已被删除，销毁监听事件 组件 事件 子实例也被销毁
    这时组件已经没有了，你无法操作里面的任何东西了。

### 问：第一次页面加载会触发哪几个钩子？

第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

### 问：DOM 渲染在 哪个周期中就已经完成？

DOM 渲染在 mounted 中就已经完成了。

### 问：简单描述每个周期具体适合哪些场景？

生命周期钩子的一些使用方法：

- beforecreate : 可以在这加个loading事件，在加载实例时触发
- created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
- mounted : 挂载元素，获取到DOM节点
- updated : 如果对数据统一处理，在这里写上相应函数
- beforeDestroy : 可以做一个确认停止事件的确认框
- nextTick : 更新数据后立即操作dom

### 问：父子组件的生命周期

仅当子组件完成挂载后，父组件才会挂载
当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）
父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的
销毁父组件时，先将子组件销毁后才会销毁父组件

兄弟组件的初始化（mounted之前）分开进行，挂载是从上到下依次进行
当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的

mixin中的生命周期与引入该组件的生命周期是仅仅关联的，且mixin的生命周期优先执行

1. 加载渲染过程 ：

先渲染父组件在父组件渲染到beforeMount,之后渲染子组件，子组件mounted后，父组件mouted，

父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

2.子组件更新过程 ：

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

3.父组件更新过程 ：

父 beforeUpdate -> 父 updated

4.销毁过程 ：

父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

#### 问：讲一下v-if和v-show区别?

1. `v-show` 不管条件是真还是假，标签都会添加到 `DOM` 中。之后切换通过 `display: none` 样式来显示隐藏元素。

2. `v-if` 如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始动态的向 `DOM` 元素里面添加元素。当条件从真变为假的时候，开始卸载这些元素。

### 问：v-html会导致哪些问题？

- 可能会导致`xss`攻击
- `v-html`会替换掉标签内部的子元素

### 问：v-for和v-if为什么不能连用？

v-for比v-if优先级高，所以嵌套使用的的话，每次v-for都会执行v-if，造成不必要的计算，影响性能。(v-if嵌套v-for来使用)

### 问：讲一下v-if和v-show区别?

1. v-show不管条件是真还是假，标签都会添加到DOM中。之后切换通过display: none样式来显示隐藏元素。

2. v-if如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始卸载这些元素。
3. 如何选择
   1. 当需要在显示与隐藏之间切片很频繁时，使用v-show
   2. 当只有一次切换时，通过使用v-if

### 问：v-for为什么要用key，和key为什么不为index(索引值)？

这个其实和Vue的虚拟DOM的Diff算法有关系，我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置插入新的节点，所以key的值就一般设置为唯一ID，避免使用索引值，有可能会重复，造成重复渲染，就失去虚拟dom在性能上的优势。击比如说我有一个数组[1,2,3,4]，如果我在数组中插入一个数据，插入的数据后面的索引值就都会被改变了，然后就要重新渲染了。

### 问：为什么组件中的data一定是函数？

因为组件是复用的，而数据是私有的，所以需要return一个新的对象，数据放在返回的对象中，，如果数据不是一个函数的话，当其他模块改变了数据，其他模块的数据也会跟着改变。

### 问：nextTick的原理

将回调函数从全部都放入回调数组中，在调用 `TimerFunc()`，会依次判断浏览器是否支持 `Promise` 回调，`MutationObserve` 回调，`setImmediate` 回调，`settimeout` 回调

### 问：跨域知道哪些

-   首先浏览器本身有个特点，同源策略，同源策略指的是：协议、域名和端口相同。

-   `JSONP`：

    -   `JSONP` 实现跨域的原理就是利用了 `<script>` 标签的 `src` 属性不受同源策略的限制，而他的实现过程就是在页面中动态创建一个 `<script>` 标签，其中的 `src` 属性放的就是我们需要请求的接口地址，然后通过 `get` 请求的方式并在 `url` 的参数种放入回调函数传给服务器，服务器在响应请求之后会将回调函数返还给前端，并且将数据以参数的形式传递回前端。（这个方法只能是 `get` 请求）
    -   `form(post)、img(get)、a(get)、link(get)、script(get)`
    -   `form` 表单有个缺陷，提交时会刷新页面，解决这个方法就是配合 `ifram` 标签一起使用。使用 `img` 标签，服务器要返回一个图片，否则图片会显示加载失败。
    -   `JSONP` 的缺点：首先这个方法只能是 `get` 请求；其次因为 `JSONP` 是从其他域中加载代码执行，如果其他域不安全，很可能会在响应中夹带一些恶意代码；第三就是要确定 `JSONP` 请求是否失败并不容易，需要开发人员自己手写计时器来检测指定时间内是否接收到了响应；第四有缓存；第五传递信息大小有限制。

-   `CORS` 跨域资源共享：

    -   `CORS` 分为两种：简单请求和非简单请求（需预检请求）
    -   简单请求
    -   非简单请求
    -   `CORS` 的缺陷：`Access-Control-Allow-Origin` 字段设置允许跨域请求的源只能设置一种或者设置为 `*`。

-   基于 `http proxy` 实现跨域

    -   开发的时候做 `proxy`

        -   `vue` 在 `index.js` 中配置

            ```js
            proxyTable:{
            	'/路径':'api接口'  ,
            	changeOrgin:true ,
            	pathRewrite:{
            	'^/list':'/list'
            }
            ```

    -   实际发布的时候使用 `nginx` 反向代理

-   基于 `iframe` 的跨域解决方案

    -   window.name
    -   document.domain
    -   location.hash
    -   post message

### 问：Vue 组件通信的方式

##### 1. 属性传递

##### 2. 发布订阅（EventBus）：`$on / $emit`

##### 3. Provied / inject

-   祖先元素向后代元素传值

##### 4. slot（插槽）

-   可以实现组件通信

##### 5. `$parent / $children`

##### 6. Vuex

### 问：对状态管理（vuex）的了解



### 问：jQuery和vue的区别

从jquery到vue或者说是到mvvm的转变则是一个思想想的转变，是将原有的直接操作dom的思想转变到操作数据上去

jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。

Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。也就是MVVM。

 vue适用的场景：复杂数据操作的后台页面，表单填写页面

jquery适用的场景：比如说一些html5的动画页面，一些需要js来操作页面样式的页面

然而二者也是可以结合起来一起使用的，vue侧重数据绑定，jquery侧重样式操作，动画效果等，则会更加高效率的完成业务需求

### 问：git 使用

![](https://gitee.com/fromStartToEnd/image-hosting-service/raw/master/img/git使用.png)

##### 1. 新建代码库

```
# 在当前目录新建一个Git代码库
$ git init
# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]
# 下载一个项目和它的整个代码历史
$ git clone [url]
```

##### 2. 配置

```
# 显示当前的Git配置
$ git config --list
# 编辑Git配置文件
$ git config -e [--global]
# 设置提交代码时的用户信息
$ git config [--global] user.name "[name]"
$ git config [--global] user.email "[email address]"
```

##### 3. 增加或者删除文件

```
# 添加指定文件到暂存区
$ git add [file1] [file2] ...
# 添加指定目录到暂存区，包括子目录
$ git add [dir]
# 添加当前目录的所有文件到暂存区
$ git add .
# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...
# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]
# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
```

##### 4. 代码提交

```
# 提交暂存区到仓库区
$ git commit -m [message]
# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]
```

##### 5. 分支

```
# 列出所有本地分支
$ git branch
# 列出所有远程分支(本地分支和远程分支)
$ git branch -r(-a)
# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]
# 新建一个分支，并切换到该分支
$ git checkout -b [branch]
# 切换到指定分支，并更新工作区
$ git checkout [branch-name]
# 合并指定分支到当前分支
$ git merge [branch]
# 删除分支
$ git branch -d [branch-name]
```

##### 6. 查看信息

```
# 显示有变更的文件
$ git status
# 显示当前分支的版本历史
$ git log
```