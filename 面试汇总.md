# HTML + CSS



# JavaScript

### 问：js数据类型



### 问：undefined 和 null 的区别



### 问：`==` 的比较规则



### 问：js为什么是单线程

- 单线程 - 只有一个线程，只能做一件事
- 原因 - 避免 `DOM` 渲染的冲突
  - 浏览器需要渲染 DOM
  - JS 可以修改 DOM 结构
  - JS 执行的时候，浏览器 DOM 渲染会暂停
  - 两段 JS 也不能同时执行（都修改 DOM 就冲突了）
  - webworker 支持多线程，但是不能访问 DOM
- 解决方案 - 异步



# 算法

### 问：数组去重

1. 使用 Set 数据结构

   1. `[...new Set(oldArr)]`
   2. `Array.from(new Set(oldArr))`

2. 拿出前面的项和后面的内容做对比

   ```js
   for (let i = 0; i < arr.length - 1; i++) {
     let item = arr[i];
     // newArr.indexOf(item) === -1 ? newArr.push(item) : '';
     // newArr.lastIndexOf(item) === -1 ? newArr.push(item) : '';
     newArr.includes(item) === false ? newArr.push(item) : '';
   }
   ```

3. 拿数组中的每一项向新容器中存储，如果已经存储过了，把当前项去掉

   ```js
   for (let i = 0; i < arr.length; i++) {
     if (typeof obj[arr[i]] !== 'undefined') {
       continue;
     }
     obj[arr[i]] = arr[i];
     newArr.push(arr[i]);
   }
   ```

4. 先排序，再相邻比较

 ### 问：排序算法

![排序算法](./笔记图片/排序算法.png)

[十大排序算法](https://www.cnblogs.com/onepixel/articles/7674659.html)

### 问：数组扁平化

1. ES6 新增方法 `Array.prototype.flat(Infinity)`
2. 递归
3. `reduce()`
4. `toString() + split()`
5. 数组的扩展运算符

# 网络

### 问：讲一下 DNS 查询

- 当客户端程序要通过一个主机名称来访问网络中的一台主机时，它首先要得到这个主机名称所对应的IP地址，因为IP数据报中允许放置的是目的主机的IP地址，而不是主机名称。可以从本机的hosts文件中得到主机名称所对应的IP地址，但如果hosts文件不能解析该主机名称时，只能通过向客户机所设定DNS服务器进行查询了。
- **本地解析：** 客户端平时得到的DNS查询记录都保存在 DNS 缓存中，客户端的操作系统中都会运行着一个 DNS 客户端程序。当其他程序提出 DNS 查询请求的时候，这个查询请求会经过 DNS 客户端程序，DNS 客户端会使用本地的缓存信息进行解析，如果可以查询到，那么 DNS 客户端程序就会直接应答这个查询，而不需要向 DNS 服务器查询。
- **直接解析：** 如果 DNS 客户端程序进行本地解析失败，也就是说本地缓存中无法查询到，那么他就会向客户端所设定的局部 DNS 服务器发送一个查询请求，要求局部 DNS 服务器进行解析，局部 DNS 服务器在得到这个请求之后会查看一个所需要查询的域名是不是自己能够应答的，如果是能够应答的，那么就会给予回答，如果不能就会查看自己的 DNS 缓存，如果能从缓存中解析，也会直接给予回应。
- **递归解析：** 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的**根域服务器**查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。
- **迭代解析：** 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。

### 问：TCP 和 UDP 的区别，TCP拥塞控制是如何实现的？



# Vue

### 问：Vue 2.0 / 3.0 双向数据绑定的实现原理

##### Vue 2.0 （ES5：`Object.defineProperty`）

```html
<body>
  姓名：<span id="spanName"></span>
  <br>
  <input type="text" name="" id="inpName">
  <script>
    let obj = {
      name: '',
    };
    let newObj = JSON.parse(JSON.stringify(obj));

    Object.defineProperty(obj, 'name', {
      get() {
        return newObj.name;
      },
      set(value) {
        if (value === newObj.name) return;
        newObj.name = value;
        observe();
      }
    });

    // let spanName = document.querySelector('#spanName');
    // let inpName = document.querySelector('#inpName');

    function observe() {
      spanName.innerHTML = obj.name;
      inpName.value = obj.name;
    }

    inpName.oninput = function () {
      obj.name = this.value;
    }
  </script>
</body>
```

##### Vue 3.0 （ES6：`Proxy`）

```html
<body>
  姓名：<span id="spanName"></span>
  <br>
  <input type="text" name="" id="inpName">
  <script>
    let obj = {};
    obj = new Proxy(obj, {
      get(target, prop) {
        // console.log(target, target[prop]);
        return target[prop];
      },
      set(target, prop, value) {
        target[prop] = value;
        observe();
        console.log(target, target[prop]);
      }
    });

    function observe() {
      spanName.innerHTML = obj.name;
      inpName.value = obj.name;
    }

    inpName.oninput = function () {
      obj.name = this.value;
    }
  </script>
</body>
```

### 问：Vue 2.0 / 3.0 双向数据绑定的实现过程



### 问：proxy 和 defineProperty 的优缺点



### 问：MVC 和 MVVM 的区别



### 问：跨域知道哪些

- 首先浏览器本身有个特点，同源策略，同源策略指的是：协议、域名和端口相同。

- `JSONP`：

  - `JSONP` 实现跨域的原理就是利用了 `<script>` 标签的 `src` 属性不受同源策略的限制，而他的实现过程就是在页面中动态创建一个 `<script>` 标签，其中的 `src` 属性放的就是我们需要请求的接口地址，然后通过 `get` 请求的方式并在 `url` 的参数种放入回调函数传给服务器，服务器在响应请求之后会将回调函数返还给前端，并且将数据以参数的形式传递回前端。（这个方法只能是 `get` 请求）
  - `form(post)、img(get)、a(get)、link(get)、script(get)`
  - `form` 表单有个缺陷，提交时会刷新页面，解决这个方法就是配合 `ifram` 标签一起使用。使用 `img` 标签，服务器要返回一个图片，否则图片会显示加载失败。
  - `JSONP` 的缺点：首先这个方法只能是 `get` 请求；其次因为 `JSONP` 是从其他域中加载代码执行，如果其他域不安全，很可能会在响应中夹带一些恶意代码；第三就是要确定 `JSONP` 请求是否失败并不容易，需要开发人员自己手写计时器来检测指定时间内是否接收到了响应；第四有缓存；第五传递信息大小有限制。

- `CORS` 跨域资源共享：

  - `CORS` 分为两种：简单请求和非简单请求（需预检请求）
  - 简单请求
  - 非简单请求
  - `CORS` 的缺陷：`Access-Control-Allow-Origin` 字段设置允许跨域请求的源只能设置一种或者设置为 `*`。

- 基于 `http proxy` 实现跨域

  - 开发的时候做 `proxy` 

    - `vue` 在 `index.js` 中配置

      ```js
      proxyTable:{
      	'/路径':'api接口'  ,  
      	changeOrgin:true ,
      	pathRewrite:{
      	'^/list':'/list'
      }
      ```

  - 实际发布的时候使用 `nginx` 反向代理

- 基于 `iframe` 的跨域解决方案

  - window.name
  - document.domain
  - location.hash
  - post message

### 问：Vue组件通信的方式

##### 1. 属性传递

##### 2. 发布订阅（EventBus）：`$on / $emit`

##### 3. Provied / inject

- 祖先元素向后代元素传值

##### 4. slot（插槽）

- 可以实现组件通信

##### 5. `$parent / $children`

##### 6. Vuex

### 问：对状态管理（vuex）的了解

